# Closest Integer With Same Weight

The "weight" of an integer is the number of set bits in its binary representation.  Weight is only defined for unsigned integers.  For an integer *n* with weight *w*, the "closest" integer with the same weight, call it *c*, is the integer with weight *w* that minimizes |*n*-*c*| where *c* != *n*. An unsigned integer that has all bits 1's or all bits 0's has no closest integer with same weight, because for an unsigned *b*-bit integer, only one number can be represented by having all *b* bits set (namely, 2\*\*(*b*-1)), and only one number can be represented by having all *b* bits unset (namely, zero).  However, outside of the two aforementioned cases, every unsigned integer *n* is guaranteed to have a closest integer *c* of the same weight.  Furthermore, it is guaranteed that the solution set is of size one, that is, there is only one unsigned integer *c* for a given valid *n* such that *c* and *n* have the same weight and |*n*-*c*| is minimized.

[closest_int_with_same_weight](https://github.com/hlpostman/challenges/blob/master/closest_int_with_same_weight/closest_int_with_same_weight.py) takes a 64-bit unsigned integer and returns the closest integer with the same weight as defined above.  The run time is linear with respect to the place of the least significant bit adjacent to an unset bit - however, it has a constant upper limit of at most int_size, an optional argument that defaults to 64 and accepts some smaller alternative integer widths.  Space complexity is constant - the return integer is stored when it is computed for clarity, but nothing else is stored.

Initialize the number we'll return to the number passed.  Since the number we'll return has to have the same number of set bits as the number passed, we can't simply flip the 2\*\*0 bit to add or subtract 1 - doing so would give us an integer very close to *n*, but it would leave us with one too many or one too few bits.  For every bit that we set, another must be unset, and visa-versa.  We'll have to "move" at least one bit.  

Clearing the *b*th bit in an unsigned integer amounts to subtracting 2\*\**b* from that number.  Setting the *b*th bit in an unsigned integer amounts to adding 2\*\**b* to that number.  Suppose we "move" one bit by clearing, or unsetting, the *u*th bit, and setting the *s*th bit.  Then the number *c* that we'll return is equal to *n* + 2\*\**s* - 2\*\**u*.  Observe then that in order to change *n* as little as possible, we should minimize |2\*\**s* - 2\*\**u*|.  Notice that minimizing |2\*\**s* - 2\*\**u*| amounts to minimizing |*s* - *u*|.  We want *u* and *s* to be close together; we don't want to let 2 expand by too many factors as we "move" the bit.  We've can't have *u* == *s* because then we'd have *c* == *n*, but we can do the next best thing.  We can have *u* == *s* +- 1.  So, we need to look through the binary representation of *n* and find two adjacent bits where one is set and one is unset.

Which 01 or 10 pair should we choose?  Well, we want to choose the least significant pair possible.  Why?  To illustrate, let's now make the substitution *u* = *s-1*, so our pair is the bit *s* and the bit *s-1*.  Let's compare what our pair will give to a pair *t* places farther into the binary representation of *n*, where *t* is any positive integer.  *s* is likewise any positive integer (*s* can't be 0 since I happened to let *u* be *s-1* rather than *s+1*).  Then we have that 2\*\**s* < 2\*\*(*s+t*).  We want to know what this means for the relationship between |2\*\**s* - 2\*\*(*s-1*)| and |2\*\*(*s+t*) - 2\*\*(*s+t-1*)|.  You might already suspect that |2\*\**s* - 2\*\*(*s-1*)| will be our better bet, the smaller number.  But suppose not.  Suppose we have
- |2\*\**s* - 2\*\*(*s-1*)| > |2\*\*(*s+t*) - 2\*\*(*s+t-1*)| by the (faulty) assumption I just made
- |2\*\**s* (1-0.5)| > |2\*\*(*s+t*) (1-0.5)| by factoring
- 2\*\**s* (0.5) > 2\*\*(*s+t*) (0.5) by simplification
- 2\*\*(*s*-1) > 2\*\*(*s+t*-1) by further simplification

By the last line above, it's clear we have a contradiction to the assumption that |2\*\**s* - 2\*\*(*s-1*)| > |2\*\*(*s+t*) - 2\*\*(*s+t-1*)| - because 2\*\**x* is a strictly increasing function where *x* is any nonnegative integer, as it is at both occurrences in the last line.  The same logic follows when *u* = *s+1*.  Another way to convince yourself of to choose the least significant pair might be to note that in binary, the difference between two bits doubles from one bit to the next.  That means the difference increases by 2\*\**b* as you head towards bit 64 - that is, the difference increases exponentially!  So, let's choose the earliest pair we can find :)

The algorithm iterates over the bits in the integer passed from least significant bit to most, considering adjacent pairs.  When it finds a pair of adjacent bits where one bit is set and the other is not, it "swaps" them.  That is, it flips both their settings.  It returns the resulting number.  In this implementation, there is an optional argument for the integer width that defaults to 64, but can accept 4, 8, 16, and 32 if you desire.
