# Closest Integer With Same Weight

The "weight" of an integer is the number of set bits in its binary representation.  Weight is only defined for unsigned integers.  For an integer *n* with weight *w*, the "closest" integer with the same weight, call it *c*, is the integer with weight *w* that minimizes |*n*-*c*| where *c* != *n*. An unsigned integer that has all bits 1's or all bits 0's has no closest integer with same weight, because for an unsigned *b*-bit integer, only one number can be represented by having all *b* bits set (namely, 2\*\*(*b*-1)), and only one number can be represented by having all *b* bits unset (namely, zero).  However, outside of the two aforementioned cases, every unsigned integer *n* is guaranteed to have a closest integer *c* of the same weight.  Furthermore, it is guaranteed that the solution set is of size one, that is, there is only one unsigned integer *c* for a given valid *n* such that *c* and *n* have the same weight and |*n*-*c*| is minimized.

[closest_int_with_same_weight](https://github.com/hlpostman/challenges/blob/master/closest_int_with_same_weight/closest_int_with_same_weight.py) takes a 64-bit unsigned integer and returns the closest integer with the same weight as defined above.  The run time is linear with respect to the place of the least significant bit adjacent to an unset bit - however, it has a constant upper limit of at most `int_size`, an optional argument that defaults to 64 and accepts some smaller alternative integer widths.  Space complexity is constant - the return integer is stored when it is computed for clarity, but this takes constant space and nothing else is stored.

We initialize the number we'll return to the number passed.  We could get an integer close to *n* by just flipping the last bit in *n*, adding or subtracting 1.  That sounds good because a change by 1 is the smallest change we can make to *n* that will give us an integer, since for any integer *n*, the two nearest integers to *n* are *n* - 1 and *n* + 1.  But this doesn't necessarily guarantee that the return number has the same weight as *n*.  If you think about it, you'll probably notice that this approach actually guarantees a result that does *not* have the same weight as *n*.  Why?  Flipping the last bit would change the number of set bits by exactly 1.  We'd end up with either one too many or one too few bits.

Our algorithm will need to be a little smarter.  If it finds a strategic bit to set, it will need to find a correspondingly strategic bit to *unset* - or vice versa.  In a sense, the algorithm will choose a set bit, and "move" it to an available (i.e. unset) spot - thus maintaining the weight of the original integer *n*.  How can we achieve this?  

We've established that clearing or setting the last bit won't work.  Let's think a little more generally now.   Clearing the *b*th bit in an unsigned integer amounts to subtracting 2\*\**b* from that number.  Setting the *b*th bit in an unsigned integer amounts to adding 2\*\**b* to that number.  Suppose we "move" one bit by clearing, or unsetting, the *u*th bit, and setting the *s*th bit.  Then the number *c* that we'll return is equal to *n* + 2\*\**s* - 2\*\**u*.  Observe then that in order to change *n* as little as possible, we should minimize |2\*\**s* - 2\*\**u*|.  Notice that minimizing |2\*\**s* - 2\*\**u*| amounts to minimizing |*s* - *u*|.  We want *u* and *s* to be close together; we don't want to let 2 expand by too many factors as we "move" the bit.  We've can't have *u* == *s* because then we'd have *c* == *n*, but we can do the next best thing.  We can have *u* == *s* +- 1 - that is, we'd like to have the pair of bits *u* and *s* as close together as possible, so close that they're actually neighbors.  So, let's have our algorithm look through the binary representation of *n* and find two adjacent bits where one is set and one is unset.  Then we can "swap" these two bits.  But how should we find this *s* and *u* pair?

Suppose there are multiple pairs in the original number *n* which have one bit set and the other bit not set.  This is quite possible, even in a small number.  For example, if *n* is 5 with binary representation 101, we have the pair 10 as well as the pair 01.  Which pair should we choose?  Well, we want to choose the least significant pair possible.  Why?  To illustrate, let's now make the substitution *u* = *s*-1, so our pair is the bit *s* and the bit *s*-1 (this is without loss of generality - we could have equivalently set *s* to be the smaller of *s* and *u*).  

Let's assume that *s* is the smallest bit in *n* having its preceding bit set differently (i.e., we have the earliest possible 01 or 10 pair in *n*).   Consider another 10 or 01 pair *t* places farther into the binary representation of *n*, where *t* is any positive integer less than `int_size`.  *s* is likewise any positive integer (*s* can't be 0 since I happened to let *u* be *s-1* rather than *s+1*).  Then we have that 2\*\**s* < 2\*\*(*s+t*).  We want to know what this means for the relationship between |2\*\**s* - 2\*\*(*s-1*)| and |2\*\*(*s+t*) - 2\*\*(*s+t-1*)|, to find out if we should choose the earliest 01 or 10 pair, or one *t* places farther along in *n*.  You might already suspect that |2\*\**s* - 2\*\*(*s-1*)| will be our better bet, the smaller number.  But suppose not.  Suppose we have
- |2\*\**s* - 2\*\*(*s-1*)| > |2\*\*(*s+t*) - 2\*\*(*s+t-1*)| by the (faulty) assumption I just made
- |2\*\**s* (1-0.5)| > |2\*\*(*s+t*) (1-0.5)| by factoring
- 2\*\**s* (0.5) > 2\*\*(*s+t*) (0.5) by simplification
- 2\*\*(*s*-1) > 2\*\*(*s+t*-1) by further simplification

By the last line above, it's clear we have a contradiction to the assumption that |2\*\**s* - 2\*\*(*s-1*)| > |2\*\*(*s+t*) - 2\*\*(*s+t-1*)| - because 2\*\**x* is a strictly increasing function where *x* is any nonnegative integer, as it is at both occurrences in the last line.  The same logic follows when *u* = *s+1*.

Another way to convince yourself to choose the least significant pair might be to note that in binary, the difference between two bits doubles from one bit to the next.  That means the difference increases by 2\*\**b* as you head towards bit 64 - that is, the difference increases exponentially!  So, let's choose the earliest pair we can find :)

The algorithm iterates over the bits in the integer passed from least significant bit to most, considering adjacent pairs.  When it finds a pair of adjacent bits where one bit is set and the other is not, it "swaps" them.  That is, it flips both their settings.  It returns the resulting number.  In this implementation, there is an optional argument for the integer width that defaults to 64, but can accept 4, 8, 16, and 32 if you desire.
